# 微前端框架对比分析：Wujie vs Qiankun

## 一、概述

本文档深入分析 Wujie 和 Qiankun 两个主流微前端框架的核心原理、架构设计和技术实现，帮助团队理解微前端技术选型的关键差异。

### 1.1 框架背景

| 特性 | Wujie | Qiankun |
|------|-------|---------|
| 开发团队 | 腾讯 | 蚂蚁金服 |
| 核心技术 | WebComponent + iframe | single-spa + Proxy |
| 沙箱方案 | iframe 天然隔离 | Proxy 代理沙箱 |
| CSS 隔离 | Shadow DOM | 动态样式隔离 |
| 成熟度 | 较新 | 成熟稳定 |

## 二、核心架构对比

### 2.1 Wujie 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                      主应用 (Main App)                       │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────┐   │
│  │              WebComponent (wujie-app)                │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │           Shadow DOM (CSS 隔离)              │    │   │
│  │  │  ┌─────────────────────────────────────┐    │    │   │
│  │  │  │        子应用 HTML/CSS 渲染          │    │    │   │
│  │  │  └─────────────────────────────────────┘    │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              iframe (JS 沙箱)                        │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │   子应用 JS 执行环境 (独立 window/document)   │    │   │
│  │  │   - Proxy 代理 window/document/location      │    │   │
│  │  │   - 路由同步机制                              │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Qiankun 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                      主应用 (Main App)                       │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────┐   │
│  │                 single-spa 路由调度                   │   │
│  │  - registerApplication() 注册子应用                   │   │
│  │  - 基于路由规则激活/卸载子应用                         │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Sandbox Container (沙箱容器)             │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │         StandardSandbox (Proxy 沙箱)         │    │   │
│  │  │   - Membrane 代理层                          │    │   │
│  │  │   - 全局变量隔离                              │    │   │
│  │  │   - 副作用收集与恢复                          │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │              Patchers (补丁系统)              │    │   │
│  │  │   - dynamicAppend (动态脚本/样式)            │    │   │
│  │  │   - windowListener (事件监听)                │    │   │
│  │  │   - interval (定时器)                        │    │   │
│  │  │   - historyListener (路由监听)               │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                子应用容器 (DOM Container)             │   │
│  │  - qiankun-head 标签替换                             │   │
│  │  - 样式隔离处理                                       │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```


## 三、JS 沙箱实现原理

### 3.1 Wujie 的 iframe 沙箱

Wujie 采用 **iframe + Proxy** 的双重隔离方案，这是其最核心的创新点。

#### 3.1.1 核心实现

```typescript
// wujie-core/src/sandbox.ts
export default class Wujie {
  public iframe: HTMLIFrameElement;      // JS 沙箱
  public shadowRoot: ShadowRoot;          // CSS 沙箱
  public proxy: WindowProxy;              // window 代理
  public proxyDocument: Object;           // document 代理
  public proxyLocation: Object;           // location 代理
  
  constructor(options) {
    // 创建 iframe 作为 JS 执行环境
    this.iframe = iframeGenerator(this, attrs, mainHostPath, appHostPath, appRoutePath);
    
    // 创建代理对象
    const { proxyWindow, proxyDocument, proxyLocation } = proxyGenerator(
      this.iframe,
      urlElement,
      mainHostPath,
      appHostPath
    );
    this.proxy = proxyWindow;
    this.proxyDocument = proxyDocument;
    this.proxyLocation = proxyLocation;
  }
}
```

#### 3.1.2 Proxy 代理实现

```typescript
// wujie-core/src/proxy.ts
export function proxyGenerator(iframe, urlElement, mainHostPath, appHostPath) {
  // Window 代理
  const proxyWindow = new Proxy(iframe.contentWindow, {
    get: (target, p) => {
      if (p === "location") return target.__WUJIE.proxyLocation;
      if (p === "self" || p === "window") return target.__WUJIE.proxy;
      return getTargetValue(target, p);
    },
    set: (target, p, value) => {
      target[p] = value;
      return true;
    },
    has: (target, p) => p in target,
  });

  // Document 代理 - 将 DOM 操作重定向到 Shadow DOM
  const proxyDocument = new Proxy({}, {
    get: function (_fakeDocument, propKey) {
      const { shadowRoot } = iframe.contentWindow.__WUJIE;
      
      // DOM 查询重定向到 shadowRoot
      if (propKey === "getElementById") {
        return new Proxy(shadowRoot.querySelector, {
          apply(target, ctx, args) {
            return target.call(shadowRoot, `[id="${args[0]}"]`);
          },
        });
      }
      // ... 其他 DOM 方法代理
    },
  });

  // Location 代理 - 处理跨域路由
  const proxyLocation = new Proxy({}, {
    get: function (_fakeLocation, propKey) {
      const location = iframe.contentWindow.location;
      if (propKey === "href") {
        return location[propKey].replace(mainHostPath, appHostPath);
      }
      return getTargetValue(location, propKey);
    },
    set: function (_fakeLocation, propKey, value) {
      if (propKey === "href") {
        return locationHrefSet(iframe, value, appHostPath);
      }
      iframe.contentWindow.location[propKey] = value;
      return true;
    },
  });

  return { proxyWindow, proxyDocument, proxyLocation };
}
```

#### 3.1.3 脚本注入执行

```typescript
// wujie-core/src/iframe.ts
export function insertScriptToIframe(scriptResult, iframeWindow) {
  let code = jsLoader(content, src, getCurUrl(proxyLocation));
  
  // 关键：将代码包装在闭包中，绑定代理对象
  if (!iframeWindow.__WUJIE.degrade && !module) {
    code = `(function(window, self, global, location) {
      ${code}
    }).bind(window.__WUJIE.proxy)(
      window.__WUJIE.proxy,
      window.__WUJIE.proxy,
      window.__WUJIE.proxy,
      window.__WUJIE.proxyLocation,
    );`;
  }
  
  scriptElement.textContent = code;
  container.appendChild(scriptElement);
}
```

### 3.2 Qiankun 的 Proxy 沙箱

Qiankun 采用纯 **Proxy** 方案实现 JS 隔离。

#### 3.2.1 StandardSandbox 实现

```typescript
// qiankun/packages/sandbox/src/core/sandbox/StandardSandbox.ts
export class StandardSandbox extends Compartment implements Sandbox {
  private readonly membrane: Membrane;
  
  constructor(name: string, globals: Endowments, incubatorContext: WindowProxy = window) {
    // 定义内置属性
    const intrinsics: Record<string, PropertyDescriptor> = {
      window: { get: getRealmGlobal, enumerable: true, configurable: false },
      self: { get: getRealmGlobal, enumerable: true, configurable: false },
      globalThis: { get: getRealmGlobal, enumerable: false, configurable: true },
      document: { value: document, writable: true, enumerable: true, configurable: true },
      // ...
    };
    
    // 创建 Membrane 代理层
    const membrane = new Membrane(incubatorContext, unscopables, {
      whitelist: [],
      endowments: { ...intrinsics, ...globals },
    });
    
    this.membrane = membrane;
  }
  
  active() {
    this.membrane.unlock();
  }
  
  inactive() {
    this.membrane.lock();
  }
}
```

#### 3.2.2 Membrane 代理层

```typescript
// qiankun/packages/sandbox/src/core/membrane/index.ts
export class Membrane {
  private locking = false;
  modifications = new Set<PropertyKey>();
  realmGlobal: WindowProxy;
  latestSetProp: PropertyKey | undefined;

  constructor(incubatorContext: WindowProxy, unscopables, opts) {
    const { target, propertiesWithGetter } = createMembraneTarget(endowments, incubatorContext);
    
    this.realmGlobal = new Proxy(target, {
      set: (membraneTarget, p, value) => {
        if (!this.locking) {
          // 白名单变量同步到全局
          if (whitelistVars.indexOf(p) !== -1) {
            incubatorContext[p] = value;
          } else {
            membraneTarget[p] = value;
          }
          this.modifications.add(p);
          this.latestSetProp = p;
          return true;
        }
        return true; // 锁定时忽略写入
      },
      
      get: (membraneTarget, p, receiver) => {
        if (p === Symbol.unscopables) return unscopables;
        if (hasOwnProperty(endowments, p)) return membraneTarget[p];
        
        const actualTarget = propertiesWithGetter.has(p) 
          ? incubatorContext 
          : p in membraneTarget ? membraneTarget : incubatorContext;
        const value = actualTarget[p];
        
        // 原生 API 需要绑定到正确的 this
        return rebindTarget2Fn(boundTarget, value, receiver);
      },
      
      has(membraneTarget, p) {
        return p in membraneTarget || p in incubatorContext;
      },
      
      // ... 其他 trap
    });
  }
  
  lock() { this.locking = true; }
  unlock() { this.locking = false; }
}
```


## 四、CSS 隔离方案

### 4.1 Wujie 的 Shadow DOM 隔离

Wujie 使用 **Shadow DOM** 实现天然的样式隔离。

```typescript
// wujie-core/src/shadow.ts
export function defineWujieWebComponent() {
  class WujieApp extends HTMLElement {
    connectedCallback(): void {
      if (this.shadowRoot) return;
      // 创建 Shadow DOM
      const shadowRoot = this.attachShadow({ mode: "open" });
      const sandbox = getWujieById(this.getAttribute(WUJIE_APP_ID));
      patchElementEffect(shadowRoot, sandbox.iframe.contentWindow);
      sandbox.shadowRoot = shadowRoot;
    }

    disconnectedCallback(): void {
      const sandbox = getWujieById(this.getAttribute(WUJIE_APP_ID));
      sandbox?.unmount();
    }
  }
  customElements?.define("wujie-app", WujieApp);
}

// 渲染模板到 Shadow DOM
export async function renderTemplateToShadowRoot(shadowRoot, iframeWindow, template) {
  const html = renderTemplateToHtml(iframeWindow, template);
  const processedHtml = await processCssLoaderForTemplate(iframeWindow.__WUJIE, html);
  shadowRoot.appendChild(processedHtml);
  
  // 设置 head 和 body 引用
  shadowRoot.head = shadowRoot.querySelector("head");
  shadowRoot.body = shadowRoot.querySelector("body");
}
```

#### 4.1.1 :root 样式兼容处理

```typescript
// wujie-core/src/shadow.ts
export function getPatchStyleElements(rootStyleSheets: Array<CSSStyleSheet>) {
  const rootCssRules = [];
  const fontCssRules = [];
  const rootStyleReg = /:root/g;

  for (let i = 0; i < rootStyleSheets.length; i++) {
    const cssRules = rootStyleSheets[i]?.cssRules ?? [];
    for (let j = 0; j < cssRules.length; j++) {
      const cssRuleText = cssRules[j].cssText;
      // :root 选择器转换为 :host
      if (rootStyleReg.test(cssRuleText)) {
        rootCssRules.push(cssRuleText.replace(rootStyleReg, ":host"));
      }
      // @font-face 需要提升到 shadowRoot 外部
      if (cssRules[j].type === CSSRule.FONT_FACE_RULE) {
        fontCssRules.push(cssRuleText);
      }
    }
  }
  // ...
}
```

### 4.2 Qiankun 的样式隔离

Qiankun 通过 **动态样式处理** 和 **qiankun-head 标签** 实现样式隔离。

```typescript
// qiankun/packages/loader/src/index.ts
readableStream
  .pipeThrough(
    createTagTransformStream([
      // 将 <head> 替换为 <qiankun-head>
      { tag: '<head>', alt: `<${qiankunHeadTagName}>` },
      { tag: '</head>', alt: `</${qiankunHeadTagName}>` },
    ], {})
  )
  .pipeTo(new WritableDOMStream(container, null, nodeTransformer));
```

## 五、应用加载机制

### 5.1 Wujie 的 HTML Entry

```typescript
// wujie-core/src/entry.ts
export default function importHTML(params) {
  const { url, opts, html } = params;
  
  return (html ? Promise.resolve(html) : fetch(url).then(res => res.text()))
    .then((html) => {
      const assetPublicPath = getPublicPath(url);
      // 解析 HTML 模板，提取脚本和样式
      const { template, scripts, styles } = processTpl(htmlLoader(html), assetPublicPath);
      
      return {
        template,
        assetPublicPath,
        getExternalScripts: () => getExternalScripts(scripts, fetch, loadError, fiber),
        getExternalStyleSheets: () => getExternalStyleSheets(styles, fetch, loadError),
      };
    });
}

// 处理 CSS Loader
export async function processCssLoader(sandbox, template, getExternalStyleSheets) {
  const composeCssLoader = compose(sandbox.plugins.map((plugin) => plugin.cssLoader));
  const processedCssList = getExternalStyleSheets().map(({ src, contentPromise }) => ({
    src,
    contentPromise: contentPromise.then((content) => composeCssLoader(content, src, curUrl)),
  }));
  return await getEmbedHTML(template, processedCssList);
}
```

### 5.2 Qiankun 的流式加载

```typescript
// qiankun/packages/loader/src/index.ts
export async function loadEntry<T>(entry, container, opts) {
  const res = typeof entry === 'string' ? await fetch(entry) : entry.res;
  
  if (res.body) {
    const entryScriptLoadedDeferred = new Deferred<T | void>();
    
    // 使用流式处理
    let readableStream = res.body.pipeThrough(new TextDecoderStream());
    
    if (streamTransformer) {
      readableStream = readableStream.pipeThrough(streamTransformer());
    }

    readableStream
      .pipeThrough(createTagTransformStream([
        { tag: '<head>', alt: `<${qiankunHeadTagName}>` },
        { tag: '</head>', alt: `</${qiankunHeadTagName}>` },
      ], {}))
      .pipeTo(new WritableDOMStream(container, null, (clone) => {
        // 节点转换处理
        const transformedNode = nodeTransformer ? nodeTransformer(clone, transformerOpts) : clone;
        
        // 处理入口脚本
        if (isEntryScript(script)) {
          script.onload = onScriptComplete.bind(null, script.onload);
          script.onerror = onScriptComplete.bind(null, script.onerror);
        }
        
        return transformedNode;
      }));

    return entryScriptLoadedDeferred.promise;
  }
}
```

## 六、生命周期管理

### 6.1 Wujie 生命周期

```typescript
// wujie-core/src/sandbox.ts
type lifecycles = {
  beforeLoad: lifecycle;    // 加载前
  beforeMount: lifecycle;   // 挂载前
  afterMount: lifecycle;    // 挂载后
  beforeUnmount: lifecycle; // 卸载前
  afterUnmount: lifecycle;  // 卸载后
  activated: lifecycle;     // 保活激活
  deactivated: lifecycle;   // 保活失活
  loadError: loadErrorHandler; // 加载错误
};

// 启动子应用
public async start(getExternalScripts) {
  this.execFlag = true;
  const scriptResultList = await getExternalScripts();
  const iframeWindow = this.iframe.contentWindow;
  iframeWindow.__POWERED_BY_WUJIE__ = true;
  
  // 执行队列管理
  syncScriptResultList.forEach((scriptResult) => {
    this.execQueue.push(() => insertScriptToIframe(scriptResult, iframeWindow));
  });
  
  // 触发 mount
  this.execQueue.push(() => this.mount());
  
  // 触发 DOMContentLoaded
  this.execQueue.push(() => {
    eventTrigger(iframeWindow.document, "DOMContentLoaded");
    eventTrigger(iframeWindow, "DOMContentLoaded");
  });
  
  // 触发 load
  this.execQueue.push(() => {
    eventTrigger(iframeWindow.document, "readystatechange");
    eventTrigger(iframeWindow, "load");
  });
  
  this.execQueue.shift()();
}

public mount(): void {
  if (this.mountFlag) return;
  if (isFunction(this.iframe.contentWindow.__WUJIE_MOUNT)) {
    this.lifecycles?.beforeMount?.(this.iframe.contentWindow);
    this.iframe.contentWindow.__WUJIE_MOUNT();
    this.lifecycles?.afterMount?.(this.iframe.contentWindow);
    this.mountFlag = true;
  }
}
```

### 6.2 Qiankun 生命周期

```typescript
// qiankun/packages/qiankun/src/core/loadApp.ts
export default async function loadApp<T>(app, configuration, lifeCycles) {
  const { mount, ...otherMicroAppConfigs } = getLifecyclesFromExports(lifecycles, appName, global);
  
  return (mountContainer) => {
    const parcelConfig: ParcelConfigObject = {
      name: appName,
      bootstrap,
      
      mount: [
        async () => { /* 性能标记 */ },
        async () => {
          microAppDOMContainer = mountContainer;
          // 重新挂载时重新加载 entry
          if (mountTimes > 1) {
            initContainer(mountContainer, appName, opts);
            const htmlString = await getPureHTMLStringWithoutScripts(entry, enhancedFetch);
            await loadEntry({ url: entry, res: new Response(htmlString) }, mountContainer, containerOpts);
          }
        },
        async () => await mountSandbox(mountContainer),
        async () => execHooksChain(toArray(beforeMount), app, global),
        async (props) => mount({ ...props, container: mountContainer }),
        async () => execHooksChain(toArray(afterMount), app, global),
        async () => { mountTimes++; },
      ],

      unmount: [
        async () => execHooksChain(toArray(beforeUnmount), app, global),
        async (props) => unmount({ ...props, container: mountContainer }),
        unmountSandbox,
        async () => execHooksChain(toArray(afterUnmount), app, global),
        async () => clearContainer(mountContainer),
      ],
    };
    
    return parcelConfig;
  };
}
```


## 七、通信机制

### 7.1 Wujie EventBus

```typescript
// wujie-core/src/event.ts
export class EventBus {
  private id: string;
  private eventObj: EventObj;

  constructor(id: string) {
    this.id = id;
    this.$clear();
    if (!appEventObjMap.get(this.id)) {
      appEventObjMap.set(this.id, {});
    }
    this.eventObj = appEventObjMap.get(this.id);
  }

  // 监听事件
  public $on(event: string, fn: Function): EventBus {
    const cbs = this.eventObj[event];
    if (!cbs) {
      this.eventObj[event] = [fn];
      return this;
    }
    if (!cbs.includes(fn)) cbs.push(fn);
    return this;
  }

  // 发送事件 - 广播到所有应用
  public $emit(event: string, ...args: Array<any>): EventBus {
    let cbs = [];
    let allCbs = [];

    // 遍历所有应用的事件对象
    appEventObjMap.forEach((eventObj) => {
      if (eventObj[event]) cbs = cbs.concat(eventObj[event]);
      if (eventObj[WUJIE_ALL_EVENT]) allCbs = allCbs.concat(eventObj[WUJIE_ALL_EVENT]);
    });

    for (let i = 0; i < cbs.length; i++) cbs[i](...args);
    for (let i = 0; i < allCbs.length; i++) allCbs[i](event, ...args);
    
    return this;
  }

  // 监听所有事件
  public $onAll(fn: (event: string, ...args: Array<any>) => any): EventBus {
    return this.$on(WUJIE_ALL_EVENT, fn);
  }
}

// 使用方式
// 主应用
import { bus } from 'wujie';
bus.$on('event-name', (data) => console.log(data));
bus.$emit('event-name', { msg: 'hello' });

// 子应用
window.$wujie.bus.$emit('event-name', { msg: 'from child' });
```

### 7.2 Qiankun 通信

Qiankun 主要通过 **props 传递** 和 **全局状态管理** 实现通信。

```typescript
// 注册时传递 props
registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:8080',
    container: '#container',
    activeRule: '/app1',
    props: {
      data: sharedData,
      onGlobalStateChange: (state) => { /* ... */ },
      setGlobalState: (state) => { /* ... */ },
    },
  },
]);

// 子应用接收
export function mount(props) {
  const { data, onGlobalStateChange, setGlobalState } = props;
  // 使用传递的数据和方法
}
```

## 八、路由同步机制

### 8.1 Wujie 路由同步

```typescript
// wujie-core/src/sync.ts
// 同步 iframe URL 到主应用
export function syncUrlToWindow(iframeWindow: Window): void {
  const { sync, id, prefix } = iframeWindow.__WUJIE;
  if (!sync) return;
  
  const { pathname, search, hash } = iframeWindow.location;
  const encodePath = encodeURIComponent(pathname + search + hash);
  
  // 更新主应用 URL 的查询参数
  const url = new URL(window.location.href);
  url.searchParams.set(id, encodePath);
  window.history.replaceState(null, '', url.toString());
}

// 同步主应用 URL 到 iframe
export function syncUrlToIframe(iframeWindow: Window): void {
  const { id } = iframeWindow.__WUJIE;
  const url = new URL(window.location.href);
  const encodePath = url.searchParams.get(id);
  
  if (encodePath) {
    const decodePath = decodeURIComponent(encodePath);
    iframeWindow.history.replaceState(null, '', decodePath);
  }
}

// History API 劫持
function patchIframeHistory(iframeWindow, appHostPath, mainHostPath) {
  const history = iframeWindow.history;
  const rawHistoryPushState = history.pushState;
  
  history.pushState = function (data, title, url) {
    const mainUrl = getAbsolutePath(url?.replace(appHostPath, ""), baseUrl);
    rawHistoryPushState.call(history, data, title, mainUrl);
    updateBase(iframeWindow, appHostPath, mainHostPath);
    syncUrlToWindow(iframeWindow);
  };
}
```

### 8.2 Qiankun 路由管理

Qiankun 基于 **single-spa** 的路由管理机制。

```typescript
// qiankun/packages/qiankun/src/apis/registerMicroApps.ts
export function registerMicroApps<T>(apps, lifeCycles) {
  unregisteredApps.forEach((app) => {
    const { name, activeRule, loader, props, entry, container } = app;

    // 使用 single-spa 注册应用
    registerApplication({
      name,
      app: async () => {
        loader(true);
        await frameworkStartedDefer.promise;
        
        const { mount, ...otherMicroAppConfigs } = (
          await loadApp({ name, entry, container, props }, frameworkConfiguration, lifeCycles)
        )(container);

        return {
          mount: [async () => loader(true), ...toArray(mount), async () => loader(false)],
          ...otherMicroAppConfigs,
        };
      },
      activeWhen: activeRule,  // 路由激活规则
      customProps: props,
    });
  });
}

// 启动 single-spa
export function start(opts = {}) {
  if (!started) {
    startSingleSpa(opts);
    started = true;
    frameworkStartedDefer.resolve();
  }
}
```

## 九、副作用管理

### 9.1 Wujie 副作用处理

```typescript
// wujie-core/src/iframe.ts
// 事件监听记录
function recordEventListeners(iframeWindow: Window) {
  const sandbox = iframeWindow.__WUJIE;
  
  iframeWindow.Node.prototype.addEventListener = function (type, handler, options) {
    // 添加事件缓存
    const elementListenerList = sandbox.elementEventCacheMap.get(this);
    if (elementListenerList) {
      elementListenerList.push({ type, handler, options });
    } else {
      sandbox.elementEventCacheMap.set(this, [{ type, handler, options }]);
    }
    return rawAddEventListener.call(this, type, handler, options);
  };
}

// 恢复事件监听
export function recoverEventListeners(rootElement, iframeWindow) {
  const sandbox = iframeWindow.__WUJIE;
  const ElementIterator = document.createTreeWalker(rootElement, NodeFilter.SHOW_ELEMENT);
  let nextElement = ElementIterator.currentNode;
  
  while (nextElement) {
    const elementListenerList = sandbox.elementEventCacheMap.get(nextElement);
    if (elementListenerList?.length) {
      elementListenerList.forEach((listener) => {
        nextElement.addEventListener(listener.type, listener.handler, listener.options);
      });
    }
    nextElement = ElementIterator.nextNode();
  }
}
```

### 9.2 Qiankun 副作用管理

```typescript
// qiankun/packages/sandbox/src/patchers/index.ts
export function patchAtMounting(appName, getContainer, opts) {
  const { sandbox } = opts;
  const basePatchers = [
    () => patchInterval(sandbox.globalThis),      // 定时器
    () => patchWindowListener(sandbox.globalThis), // 事件监听
    () => patchHistoryListener(),                  // 路由监听
  ];
  
  return patchersInSandbox[sandbox.type].map((patch) => patch());
}

// qiankun/packages/sandbox/src/patchers/interval.ts
export default function patchInterval(globalContext) {
  const intervalIds: number[] = [];
  const rawSetInterval = globalContext.setInterval;
  
  globalContext.setInterval = (...args) => {
    const intervalId = rawSetInterval(...args);
    intervalIds.push(intervalId);
    return intervalId;
  };
  
  // 返回清理函数
  return function free() {
    intervalIds.forEach((id) => globalContext.clearInterval(id));
    globalContext.setInterval = rawSetInterval;
    
    return function rebuild() {
      // 重建逻辑
    };
  };
}

// qiankun/packages/sandbox/src/patchers/windowListener.ts
export default function patchWindowListener(globalContext) {
  const listenerMap = new Map<string, EventListenerOrEventListenerObject[]>();
  const rawAddEventListener = globalContext.addEventListener;
  const rawRemoveEventListener = globalContext.removeEventListener;

  globalContext.addEventListener = (type, listener, options) => {
    const listeners = listenerMap.get(type) || [];
    listenerMap.set(type, [...listeners, listener]);
    return rawAddEventListener.call(globalContext, type, listener, options);
  };

  return function free() {
    listenerMap.forEach((listeners, type) => {
      listeners.forEach((listener) => {
        globalContext.removeEventListener(type, listener);
      });
    });
    
    globalContext.addEventListener = rawAddEventListener;
    globalContext.removeEventListener = rawRemoveEventListener;
    
    return function rebuild() {
      listenerMap.forEach((listeners, type) => {
        listeners.forEach((listener) => {
          globalContext.addEventListener(type, listener);
        });
      });
    };
  };
}
```


## 十、特性对比总结

### 10.1 核心特性对比

| 特性 | Wujie | Qiankun |
|------|-------|---------|
| **JS 沙箱** | iframe + Proxy | 纯 Proxy |
| **CSS 隔离** | Shadow DOM | 动态样式处理 |
| **隔离级别** | 天然强隔离 | 需要配置 |
| **子应用改造** | 几乎无需改造 | 需要导出生命周期 |
| **保活模式** | ✅ 原生支持 | ❌ 需要额外处理 |
| **预加载** | ✅ 支持 | ✅ 支持 |
| **Vite 支持** | ✅ 原生支持 | ⚠️ 需要插件 |
| **路由同步** | ✅ 内置支持 | ⚠️ 需要配置 |
| **通信机制** | EventBus | Props + 全局状态 |
| **降级方案** | ✅ iframe 降级 | ❌ 无 |

### 10.2 优缺点分析

#### Wujie 优点
1. **天然隔离**：iframe 提供完整的 JS 运行环境隔离
2. **CSS 隔离彻底**：Shadow DOM 实现样式完全隔离
3. **子应用改造少**：无需导出生命周期函数
4. **保活模式**：支持子应用状态保持
5. **Vite 友好**：原生支持 ESM 模块
6. **降级方案**：不支持 WebComponent 时可降级到 iframe

#### Wujie 缺点
1. **iframe 通信开销**：跨 iframe 通信有一定性能损耗
2. **SEO 不友好**：Shadow DOM 内容不利于 SEO
3. **调试复杂**：多层嵌套增加调试难度
4. **生态较新**：社区资源相对较少

#### Qiankun 优点
1. **成熟稳定**：经过大量生产验证
2. **生态丰富**：社区资源和文档完善
3. **灵活配置**：沙箱和样式隔离可配置
4. **single-spa 基础**：路由管理成熟

#### Qiankun 缺点
1. **子应用改造**：需要导出生命周期函数
2. **样式隔离不彻底**：可能存在样式污染
3. **Vite 支持差**：需要额外插件支持
4. **沙箱逃逸风险**：Proxy 沙箱存在边界情况

### 10.3 适用场景

#### 推荐使用 Wujie
- 需要强隔离的场景
- 子应用技术栈差异大
- 使用 Vite 构建的项目
- 需要保活功能
- 子应用改造成本敏感

#### 推荐使用 Qiankun
- 追求稳定性的大型项目
- 需要丰富的社区支持
- 子应用可以统一改造
- 对 SEO 有要求
- 已有 single-spa 经验

## 十一、我们的选择：Wujie

基于 erp-web 项目的实际情况，我们选择 Wujie 作为微前端框架，主要原因：

1. **强隔离需求**：ERP 系统模块众多，需要彻底的样式和 JS 隔离
2. **技术栈多样**：可能集成不同技术栈的子应用
3. **保活需求**：部分模块需要保持状态
4. **改造成本**：希望最小化子应用改造
5. **Vite 支持**：项目使用 Vite 构建

## 十二、参考资料

- [Wujie 官方文档](https://wujie-micro.github.io/doc/)
- [Qiankun 官方文档](https://qiankun.umijs.org/)
- [single-spa 文档](https://single-spa.js.org/)
- [Shadow DOM MDN](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM)
- [Proxy MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
